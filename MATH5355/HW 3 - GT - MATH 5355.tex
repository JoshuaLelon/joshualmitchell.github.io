% Thank you Josh Davis for this template!
% https://github.com/jdavis/latex-homework-template/blob/master/homework.tex

\documentclass{article}

\newcommand{\hmwkTitle}{HW \#3}

% \input{ShortcutsGraphTheory}

% ----------

% Packages

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{chngcntr}
\usepackage{blkarray}
% Libraries

\usetikzlibrary{automata, positioning, arrows}

\graphicspath{{/Users/jm/iclouddrive/5355pics/}}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{}
\rhead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}
\setcounter{secnumdepth}{0}

\newcommand{\hmwkClass}{MATH 5355 / Graph Theory}        % Class
\newcommand{\hmwkClassInstructor}{Dr. Shen}           % Instructor
\newcommand{\hmwkAuthorName}{\textbf{Joshua Mitchell}} % Author

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small\vspace{0.1in}\large{\textit{\hmwkClassInstructor}}
    \vspace{3in}
}

\author{\hmwkAuthorName}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

%
% Various Helper Commands
%

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}


% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Formatting commands:

\newcommand{\mt}[1]{\ensuremath{#1}}
\newcommand{\nm}[1]{\textrm{#1}}

\newcommand\bsc[2][\DefaultOpt]{%
  \def\DefaultOpt{#2}%
  \section[#1]{#2}%
}
\newcommand\ssc[2][\DefaultOpt]{%
  \def\DefaultOpt{#2}%
  \subsection[#1]{#2}%
}
\newcommand{\bgpf}{\begin{proof} $ $\newline}

\newcommand{\bgeq}{\begin{equation*}}
\newcommand{\eeq}{\end{equation*}}	

\newcommand{\balist}{\begin{enumerate}[label=\alph*.]}
\newcommand{\elist}{\end{enumerate}}

\newcommand{\bilist}{\begin{enumerate}[label=\roman*)]}	

\newcommand{\bgsp}{\begin{split}}
% \newcommand{\esp}{\end{split}} % doesn't work for some reason.

\newcommand\prs[1]{~~~\textbf{(#1)}}

\newcommand{\lt}[1]{\textbf{Let: } #1}
     							   %  if you're setting it to be true
\newcommand{\supp}[1]{\textbf{Suppose: } #1}
     							   %  Suppose (if it'll end up false)
\newcommand{\wts}[1]{\textbf{Want to show: } #1}
     							   %  Want to show
\newcommand{\as}[1]{\textbf{Assume: } #1}
     							   %  if you think it follows from truth
\newcommand{\bpth}[1]{\textbf{(#1)}}

\newcommand{\step}[2]{\begin{equation}\tag{#2}#1\end{equation}}
\newcommand{\epf}{\end{proof}}

\newcommand{\dbs}[3]{\mt{#1_{#2_#3}}}

\newcommand{\sidenote}[1]{-----------------------------------------------------------------Side Note----------------------------------------------------------------
#1 \

---------------------------------------------------------------------------------------------------------------------------------------------}

% Analysis / Logical commands:

\newcommand{\br}{\mt{\mathbb{R}} }       % |R
\newcommand{\bq}{\mt{\mathbb{Q}} }       % |Q
\newcommand{\bn}{\mt{\mathbb{N}} }       % |N
\newcommand{\bc}{\mt{\mathbb{C}} }       % |C
\newcommand{\bz}{\mt{\mathbb{Z}} }       % |Z

\newcommand{\ep}{\mt{\epsilon} }         % epsilon
\newcommand{\fa}{\mt{\forall} }          % for all
\newcommand{\afa}{\mt{\alpha} }
\newcommand{\bta}{\mt{\beta} }
\newcommand{\mem}{\mt{\in} }
\newcommand{\exs}{\mt{\exists} }

\newcommand{\es}{\mt{\emptyset} }        % empty set
\newcommand{\sbs}{\mt{\subset} }         % subset of
\newcommand{\fs}[2]{\{\uw{#1}{1}, \uw{#1}{2}, ... \uw{#1}{#2}\}}

\newcommand{\lra}{ \mt{\longrightarrow} } % implies ----->
\newcommand{\rar}{ \mt{\Rightarrow} }     % implies -->

\newcommand{\lla}{ \mt{\longleftarrow} }  % implies <-----
\newcommand{\lar}{ \mt{\Leftarrow} }      % implies <--

\newcommand{\av}[1]{\mt{|}#1\mt{|}}  % absolute value

\newcommand{\prn}[1]{(#1)}
\newcommand{\bk}[1]{\{#1\}}

\newcommand{\ps}{\mt{\operatorname{+}} }
\newcommand{\ms}{\mt{\operatorname{-}} }

\newcommand{\ls}{\mt{\operatorname{<}} }
\newcommand{\gr}{\mt{\operatorname{>}} }

\newcommand{\lse}{\mt{\operatorname{\leq}} }
\newcommand{\gre}{\mt{\operatorname{\geq}} }

\newcommand{\eql}{ \mt{\operatorname{=}} }

\newcommand{\pr}{\mt{^\prime}} 		   % prime (i.e. R')
\newcommand{\uw}[2]{#1\mt{_{#2}}}
\newcommand{\uf}[2]{#1\mt{^{#2}}}
\newcommand{\frc}[2]{\mt{\frac{#1}{#2}}}
\newcommand{\lmti}[1]{\mt{\displaystyle{\lim_{#1 \to \infty}}}}
\newcommand{\limt}[2]{\mt{\displaystyle{\lim_{#1 \to #2}}}}

\newcommand{\bnm}[2]{\mt{#1\setminus{#2}}}
\newcommand{\bnt}[2]{\mt{\textrm{#1}\setminus{\textrm{#2}}}}
\newcommand{\bi}{\bnm{\mathbb{R}}{\mathbb{Q}}}

\newcommand{\urng}[2]{\mt{\bigcup_{#1}^{#2}}}
\newcommand{\nrng}[2]{\mt{\bigcap_{#1}^{#2}}}
\newcommand{\nck}[2]{\mt{{#1 \choose #2}}}

\newcommand{\nbho}[3]{\textrm{N(}#1, #2\textrm{) }\cap \textrm{ #3} \neq \emptyset}
     							   %  N(x, eps) intersect S \= emptyset
\newcommand{\nbhe}[3]{\textrm{N(}#1, #2\textrm{) }\cap \textrm{ #3} = \emptyset}
     							   %  N(x, eps) intersect S  = emptyset
\newcommand{\dnbho}[3]{\textrm{N*(}#1, #2\textrm{) }\cap \textrm{ #3} \neq \emptyset}
     							   %  N*(x, eps) intersect S \= emptyset
\newcommand{\dnbhe}[3]{\textrm{N*(}#1, #2\textrm{) }\cap \textrm{ #3} = \emptyset}
     							   %  N*(x, eps) intersect S = emptyset
     							   
\newcommand{\eqn}[1]{\[#1\]}

\newcommand{\txt}[1]{\text{#1}} % Not new command, but remember \text for text in eqns
\newcommand{\tl}{\mt{\thicksim}}
\newcommand{\mn}[1]{\mt{\overline{#1}}}
\newcommand{\sg}{\mt{\sigma}}
\newcommand{\ssq}{\mt{\sigma^2}}	

\newcommand{\bh}[1]{\mathbf{\hat{\text{$#1$}}}}
\newcommand{\bth}{\mt{\bh{\beta}}}
\newcommand{\yh}{\mt{\bh{Y}}}

\newcommand{\exv}[1]{E[#1]}
\newcommand{\vrn}[1]{V[#1]}

\newcommand{\gv}{ \mt{|} }

\newcommand{\cov}[2]{\txt{Cov(#1, #2)}}

\newcommand{\img}[1]{
\begin{figure}[h]
  \includegraphics[width=0.5\linewidth]{#1}
\end{figure}
}
\newcommand\tab[1][1cm]{\hspace*{#1}}	
\newcommand{\sumin}[1]{\mt{\sum_{i = 1}^n #1}}

\newcommand{\brm}[1]{\begin{pmatrix} #1 \end{pmatrix}}

\newcommand{\inm}[1]{\mt{\left\[ \begin{smallmatrix} #1 \end{smallmatrix} \right\]}}

\newcommand{\lbm}[4]{
	  \begin{blockarray}{#1} % a c for every row, plus the c-labels
        #2 \\ % & c-label1 & c-label2 & c-label3...
      \begin{block}{c(#3)} % a c for every column only
        #4 % r-label1 & data & data & data ... \\
           % r-label2 & data & data & data ... \\
           % ...
           % r-labeln & data & data & data ... \\
      \end{block}
    \end{blockarray}
}

% Example:
% \[\lbm{ccccc}{& H & y & d}{cccc}{H & 4 & 4 & 4 \\
% Y & 3 & 3 & 3 \\
% D & 2 & 2 & 2 \\
% D & 2 & 2 & 2 \\}\]

\newcommand{\unds}[2]{\mt{\underset{#1}{#2}}} % stuff underneath!
	 
% ----------

\begin{document}

\bsc{Hand In: (1.4): 8, 23, 37\tab (2.1): 4, 10, 29}{
\ssc{Exercise 1.4.8}{
Prove that \exs an n-vertex tournament with \uf{d}{-}(v) \eql \uf{d}{+}(v) \fa v \mem V(T) iff n is odd.
\bgpf
\lra 

\lt{T be a complete, oriented graph st \uf{d}{-}(v) \eql \uf{d}{+}(v) \fa v \mem V(T)}

We know that v is adjacent to all the other n \ms 1 vertices, and that \av{E(T)} \eql \frc{n(n - 1)}{2} where \av{V(T)} \eql n

By Proposition 1.4.18, we know that:
\eqn{\sum_{v\textrm{ \mem }V(D)} d^+(v) = \sum_{v\textrm{ \mem }V(D)} d^-(v) = E(D)}
So, 
\eqn{d^+(v) + d^-(v) = n - 1}
Case:
\bilist
\item n is even
	
	Then,
	\eqn{d^+(v) + d^-(v) = n - 1 = 2k - 1, k \mem \bn}
	(an odd number)
	
	So, one of \bk{\uf{d}{+}(v), \uf{d}{-}(v)} is even, and the other is odd.
	
	This implies that \uf{d}{+}(v) cannot equal \uf{d}{-}(v).
\item n is odd
	
	Then,
	\eqn{d^+(v) + d^-(v) = n - 1 = 2k + 1 - 1 = 2k, k \mem \bn}
	(an even number)
	
	If we let \uf{d}{+}(v) \eql \uf{d}{-}(v) \fa v \mem V(T), then we can imagine all vertices \mem V(T) in a circle with k edges with v as a head, and k edges with v as a tail. Simply rotating this configuration around creates a tournament st \uf{d}{+}(v) \eql \uf{d}{-}(v) \fa v \mem V(T) and n is odd.
\elist

\lla

We have seen above that if n is odd, then creating a tournament such that \uf{d}{+}(v) \eql \uf{d}{-}(v) \fa v \mem V(T) is possible.
\epf
}

\newpage

\ssc{Exercise 1.4.23}{

Prove that every graph G has an orientation D that is "balanced" at each vertex, meaning that
\step{\av{\uf{d}{+}_D(v) - \uf{d}{-}_D(v)} \lse 1 \textrm{ \fa v \mem V(G)}}{1}
\bgpf
Recall that a graph is Eulerian iff it has at most one non-trivial component and its vertices all have an even degree.

First off, let's make sure that G has no trivial components by adding an edge between any vertices of degree 0.

Now, \fa v \mem V(G) st deg(v) is odd, let's add edges such that each v is paired with another v of odd degree.

If the number of vertices of odd degree is odd, then we can just pair up all the odd vertices except one, and save the last odd vertex for later - let's call it \uw{v}{1} if it exists.

Now, at this point, we can make a Eulerian trail of G such that each edge in the trail is oriented the same way. If \uw{v}{1} exists, it becomes the start of the trail. If not, pick any arbitrary v \mem V(G) to be the start.

Notice that, at this point, G fits condition \bpth{1}.

If we delete all the edges we added, then G is still balanced since

\balist
\item all the vertices of degree 0 are balanced by definition
\item all the vertices of even degree that became odd are still balanced since \uf{d}{+}(v) \ms \uf{d}{-}(v) is either 1 or $-1$.
\item \uw{v}{1}, if it existed, is balanced since \uf{d}{+}(v) \ms \uf{d}{-}(v) is either 1 or $-1$.
\elist

Hence, result.
\epf
}

\ssc{Exercise 1.4.37}{

Consider the following algorithm whose input is a tournament T.

\begin{enumerate}
  \item Select a vertex x in T.
  \item if (\uf{d}{-}(v) == 0) call x a king of T and stop
  \item else: delete \bk{x} $\cup$ \uf{N}{+}(x) from T to form T\pr
  \item Run the algorithm on T\pr. Call the output a king in T and then stop.
\end{enumerate}

Prove that this algorithm terminates and produces a king in T.
\bgpf
Case
\bilist
\item x is a king. Then, result.
\item x is not a king.
	
	So, after \bk{x} $\cup$ \uf{N}{+}(x) is deleted, \uf{N}{-}(v) will still exist, which is nonempty by definition.
	
	In fact, what's leftover is actually a tournament since deleting a vertex deletes all edges attached to it, which makes every leftover vertex still connected to every other leftover vertex.
	
	By induction, a king will eventually chosen since, at the very worst, you'll end up with a vertex with no edges (which is a king by default).
\elist
\epf

}

\ssc{Exercise 2.1.4}{

Prove or disprove:

Every graph with fewer edges than vertices has a component that is a tree.
\bgpf
\lt{G be a graph st \av{E(G)} \ls \av{V(G)}}

Then \av{V(G)} \ms \av{E(G)} \gre 1
	
If \mt{\delta}(G) \eql 0, then there must exist a vertex with no edges, which is by definition a tree component.
	
On the other hand, if \mt{\delta}(G) \gr 0, then \mt{\Delta}(G) must be 1, which makes G contain at least one path, and therefore contains at least one tree component.
\epf

}
\ssc{Exercise 2.1.10}{

Let u and v be vertices in a connected n-vertex simple graph.

Prove that if d(u, v) \gr 2, then d(u) \ps d(v) \lse n \ps 1 \ms d(u, v).
\bgpf 
\lt{u, v \mem V(G) st d(u, v) \gr 2 and \av{V(G)}\eql n}

Notice that if G is only a u, v-path with two vertices in between, then

n \eql 4

d(u, v) \eql 3

d(u) \eql 1

d(v) \eql 1

For this specific base case, d(u) \ps d(v) \lse n \ps 1 \ms d(u, v), since 1 \ps 1 \lse 4 \ps 1 \ms 3 \lra 2 \lse 2

Notice that if a vertex is added between who adjacent vertices in the u, v-path, d(u,v) increases by one and n increases by 1.

However, if a vertex is added that doesn't increase the path length, d(u,v) does not increase, but n still increases.

Hence, you can add a vertex anywhere, and if d(u, v) \gre 3, then the inequality holds. You can also do this any number of times.

Notice also that any vertices added to be either adjacent to u or adjacent to v will increase n by that amount.

Notice also that this will not change d(u, v) if the vertices are simply appended.

Since any net increase in d(u) or d(v) will result in the same net increase on the other side of the inequality through n, the inequality holds for any degree of u or v \gr 0

Hence, if u, v \mem V(G) where G is a connected n-vertex simple graph and d(u, v) \gr 2, then d(u) \ps d(v) \lse n \ps 1 - d(u, v).

\epf

Construct examples to show that this can fail whenever n \gre 3 and d(u, v) \lse 2.

\uw{K}{3}

Pick any two unique vertices from V(\uw{K}{3}). 

d(u) \ps d(v) \lse n \ps 1 \ms d(u, v)

2 \ps 2 \lse 3 \ps 1 \ms 1

4 \lse 3 (which is untrue)

}

\newpage

\ssc{Exercise 2.1.29}{

Prove that, since every tree is bipartite, every tree has a leaf in its larger partite set (in both if they have equal size).

\textbf{Technically, according to the definition of a leaf (a vertex with degree 1), this proof is not accurate. A counter example is a tree with one vertex of degree 0.}

\textbf{However, for the sake of the homework problem, I will try to prove it assuming the minimum amount of edges is 1.}

\bgpf
\lt{T be a tree, X and Y be the partitions of T st \av{X} \gre \av{Y}}

\supp{X has no leaf}

This implies that the minimum degree of each v \mem X is 2.

So, X must be adjacent to at least \av{X} \ps 1 other vertices not in X.

Since \av{Y} \lse \av{X}, there must be at least one other vertex that X is adjacent to that is part of neither Y nor X. A contradiction.

Hence, every partite set equal to or larger than the other partite set of a tree must contain a leaf.

\epf 
}
}

\end{document}